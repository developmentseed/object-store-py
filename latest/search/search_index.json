{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"object-store-rs","text":"<p>A Python interface and pyo3 integration to the Rust <code>object_store</code> crate. This crate provides a uniform API for interacting with object storage services and local files. Using this library, the same code can run in multiple clouds and local test environments, via a simple runtime configuration change.</p> <ul> <li>Easy to install with no Python dependencies.</li> <li>Full static type hinting</li> <li>Full sync and async API</li> <li>Helpers for constructing from environment variables and <code>boto3.Session</code> objects</li> </ul> <p>Among the included backend are:</p> <ul> <li>Amazon S3 and S3-compliant APIs like Cloudflare R2</li> <li>Google Cloud Storage</li> <li>Azure Blob Gen1 and Gen2 accounts (including ADLS Gen2)</li> <li>Local filesystem</li> <li>In-memory storage</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install object-store-rs\n</code></pre>"},{"location":"#comparison-to-object-store-python","title":"Comparison to object-store-python","text":"<ul> <li>More maintainable API than object-store-python.</li> <li>Fewer classes. Use native Python (typed) dicts and objects where possible.</li> </ul>"},{"location":"#usage","title":"Usage","text":""},{"location":"#constructing-a-store","title":"Constructing a store","text":"<p>For ease of use and accurate validation, there are separate classes for each backend.</p> <p>TODO: finish doc here</p>"},{"location":"#configuration","title":"Configuration","text":"<ul> <li>Each store concept has their own configuration. This is covered in the docs, and string literals are in the type hints.</li> </ul>"},{"location":"#interacting-with-a-store","title":"Interacting with a store","text":"<p>All methods for interacting with a store are exported as top-level functions, such as <code>get</code>, <code>put</code>, <code>list</code>, and <code>delete</code>.</p> <pre><code>import object_store_rs as obs\n\nstore = obs.store.MemoryStore()\n\nobs.put_file(store, \"file.txt\", b\"hello world!\")\nresponse = obs.get(store, \"file.txt\")\nresponse.meta\n# {'size': 12,\n#  'last_modified': datetime.datetime(2024, 10, 18, 4, 8, 12, 57046, tzinfo=datetime.timezone.utc),\n#  'version': None,\n#  'e_tag': '0',\n#  'location': 'file.txt'}\n\nassert response.bytes() == b\"hello world!\"\n\nbyte_range = obs.get_range(store, \"file.txt\", offset=0, length=5)\nassert byte_range == b\"hello\"\n\nobs.copy(store, \"file.txt\", \"other.txt\")\nassert obs.get(store, \"other.txt\").bytes() == b\"hello world!\"\n</code></pre> <p>All of these methods also have <code>async</code> counterparts, suffixed with <code>_async</code>.</p> <pre><code>import object_store_rs as obs\n\nstore = obs.store.MemoryStore()\n\nawait obs.put_file_async(store, \"file.txt\", b\"hello world!\")\nresponse = await obs.get_async(store, \"file.txt\")\nresponse.meta\n# {\n#     \"last_modified\": datetime.datetime(\n#         2024, 10, 18, 4, 14, 39, 630310, tzinfo=datetime.timezone.utc\n#     ),\n#     \"size\": 12,\n#     \"location\": \"file.txt\",\n#     \"version\": None,\n#     \"e_tag\": \"0\",\n# }\nassert await response.bytes_async() == b\"hello world!\"\n\nbyte_range = await obs.get_range_async(store, \"file.txt\", offset=0, length=5)\nassert byte_range == b\"hello\"\n\nawait obs.copy_async(store, \"file.txt\", \"other.txt\")\nresp = await obs.get_async(store, \"other.txt\")\nassert await resp.bytes_async() == b\"hello world!\"\n</code></pre>"},{"location":"api/copy/","title":"Copy","text":""},{"location":"api/copy/#object_store_rs.copy","title":"object_store_rs.copy","text":"<pre><code>copy(store: ObjectStore, from_: str, to: str) -&gt; None\n</code></pre> <p>Copy an object from one path to another in the same object store.</p> <p>If there exists an object at the destination, it will be overwritten.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>ObjectStore</code>)           \u2013            <p>The ObjectStore instance to use.</p> </li> <li> <code>from_</code>               (<code>str</code>)           \u2013            <p>Source path</p> </li> <li> <code>to</code>               (<code>str</code>)           \u2013            <p>Destination path</p> </li> </ul>"},{"location":"api/copy/#object_store_rs.copy_async","title":"object_store_rs.copy_async  <code>async</code>","text":"<pre><code>copy_async(store: ObjectStore, from_: str, to: str) -&gt; None\n</code></pre> <p>Call <code>copy</code> asynchronously.</p> <p>Refer to the documentation for copy.</p>"},{"location":"api/delete/","title":"Delete","text":""},{"location":"api/delete/#object_store_rs.delete","title":"object_store_rs.delete","text":"<pre><code>delete(store: ObjectStore, location: str) -&gt; None\n</code></pre> <p>Delete the object at the specified location.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>ObjectStore</code>)           \u2013            <p>The ObjectStore instance to use.</p> </li> <li> <code>location</code>               (<code>str</code>)           \u2013            <p>The path within ObjectStore to delete.</p> </li> </ul>"},{"location":"api/delete/#object_store_rs.delete_async","title":"object_store_rs.delete_async  <code>async</code>","text":"<pre><code>delete_async(store: ObjectStore, location: str) -&gt; None\n</code></pre> <p>Call <code>delete</code> asynchronously.</p> <p>Refer to the documentation for delete.</p>"},{"location":"api/get/","title":"Get","text":""},{"location":"api/get/#object_store_rs.get","title":"object_store_rs.get","text":"<pre><code>get(\n    store: ObjectStore, location: str, *, options: GetOptions | None = None\n) -&gt; GetResult\n</code></pre> <p>Return the bytes that are stored at the specified location.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>ObjectStore</code>)           \u2013            <p>The ObjectStore instance to use.</p> </li> <li> <code>location</code>               (<code>str</code>)           \u2013            <p>The path within ObjectStore to retrieve.</p> </li> <li> <code>options</code>               (<code>GetOptions | None</code>, default:                   <code>None</code> )           \u2013            <p>options for accessing the file. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GetResult</code>           \u2013            <p>GetResult</p> </li> </ul>"},{"location":"api/get/#object_store_rs.get_async","title":"object_store_rs.get_async  <code>async</code>","text":"<pre><code>get_async(\n    store: ObjectStore, location: str, *, options: GetOptions | None = None\n) -&gt; GetResult\n</code></pre> <p>Call <code>get</code> asynchronously.</p> <p>Refer to the documentation for get.</p>"},{"location":"api/get/#object_store_rs.get_range","title":"object_store_rs.get_range","text":"<pre><code>get_range(store: ObjectStore, location: str, offset: int, length: int) -&gt; bytes\n</code></pre> <p>Return the bytes that are stored at the specified location in the given byte range.</p> <p>If the given range is zero-length or starts after the end of the object, an error will be returned. Additionally, if the range ends after the end of the object, the entire remainder of the object will be returned. Otherwise, the exact requested range will be returned.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>ObjectStore</code>)           \u2013            <p>The ObjectStore instance to use.</p> </li> <li> <code>location</code>               (<code>str</code>)           \u2013            <p>The path within ObjectStore to retrieve.</p> </li> <li> <code>offset</code>               (<code>int</code>)           \u2013            <p>The start of the byte range.</p> </li> <li> <code>length</code>               (<code>int</code>)           \u2013            <p>The number of bytes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes</code>           \u2013            <p>bytes</p> </li> </ul>"},{"location":"api/get/#object_store_rs.get_range_async","title":"object_store_rs.get_range_async  <code>async</code>","text":"<pre><code>get_range_async(\n    store: ObjectStore, location: str, offset: int, length: int\n) -&gt; bytes\n</code></pre> <p>Call <code>get_range</code> asynchronously.</p> <p>Refer to the documentation for get_range.</p>"},{"location":"api/get/#object_store_rs.get_ranges","title":"object_store_rs.get_ranges","text":"<pre><code>get_ranges(\n    store: ObjectStore,\n    location: str,\n    offsets: Sequence[int],\n    lengths: Sequence[int],\n) -&gt; List[bytes]\n</code></pre> <p>Return the bytes that are stored at the specified locationin the given byte ranges</p> <p>To improve performance this will:</p> <ul> <li>Combine ranges less than 10MB apart into a single call to <code>fetch</code></li> <li>Make multiple <code>fetch</code> requests in parallel (up to maximum of 10)</li> </ul> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>ObjectStore</code>)           \u2013            <p>The ObjectStore instance to use.</p> </li> <li> <code>location</code>               (<code>str</code>)           \u2013            <p>The path within ObjectStore to retrieve.</p> </li> <li> <code>offsets</code>               (<code>Sequence[int]</code>)           \u2013            <p>A sequence of <code>int</code> where each offset starts.</p> </li> <li> <code>lengths</code>               (<code>Sequence[int]</code>)           \u2013            <p>A sequence of <code>int</code> representing the number of bytes within each range.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[bytes]</code>           \u2013            <p>A sequence of <code>bytes</code>, one for each range.</p> </li> </ul>"},{"location":"api/get/#object_store_rs.get_ranges_async","title":"object_store_rs.get_ranges_async  <code>async</code>","text":"<pre><code>get_ranges_async(\n    store: ObjectStore,\n    location: str,\n    offsets: Sequence[int],\n    lengths: Sequence[int],\n) -&gt; List[bytes]\n</code></pre> <p>Call <code>get_ranges</code> asynchronously.</p> <p>Refer to the documentation for get_ranges.</p>"},{"location":"api/get/#object_store_rs.GetOptions","title":"object_store_rs.GetOptions","text":"<p>               Bases: <code>TypedDict</code></p> <p>Options for a get request, such as range</p>"},{"location":"api/get/#object_store_rs.GetOptions.head","title":"head  <code>instance-attribute</code>","text":"<pre><code>head: bool\n</code></pre> <p>Request transfer of no content</p> <p>datatracker.ietf.org/doc/html/rfc9110#name-head</p>"},{"location":"api/get/#object_store_rs.GetOptions.if_match","title":"if_match  <code>instance-attribute</code>","text":"<pre><code>if_match: str | None\n</code></pre> <p>Request will succeed if the <code>ObjectMeta::e_tag</code> matches otherwise returning [<code>Error::Precondition</code>]</p> <p>See datatracker.ietf.org/doc/html/rfc9110#name-if-match</p> <p>Examples:</p> <pre><code>If-Match: \"xyzzy\"\nIf-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\nIf-Match: *\n</code></pre>"},{"location":"api/get/#object_store_rs.GetOptions.if_modified_since","title":"if_modified_since  <code>instance-attribute</code>","text":"<pre><code>if_modified_since: datetime | None\n</code></pre> <p>Request will succeed if the object has not been modified since otherwise returning [<code>Error::Precondition</code>]</p> <p>Some stores, such as S3, will only return <code>NotModified</code> for exact timestamp matches, instead of for any timestamp greater than or equal.</p> <p>datatracker.ietf.org/doc/html/rfc9110#section-13.1.4</p>"},{"location":"api/get/#object_store_rs.GetOptions.if_none_match","title":"if_none_match  <code>instance-attribute</code>","text":"<pre><code>if_none_match: str | None\n</code></pre> <p>Request will succeed if the <code>ObjectMeta::e_tag</code> does not match otherwise returning [<code>Error::NotModified</code>]</p> <p>See datatracker.ietf.org/doc/html/rfc9110#section-13.1.2</p> <p>Examples:</p> <pre><code>If-None-Match: \"xyzzy\"\nIf-None-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\nIf-None-Match: *\n</code></pre>"},{"location":"api/get/#object_store_rs.GetOptions.if_unmodified_since","title":"if_unmodified_since  <code>instance-attribute</code>","text":"<pre><code>if_unmodified_since: datetime | None\n</code></pre> <p>Request will succeed if the object has been modified since</p> <p>datatracker.ietf.org/doc/html/rfc9110#section-13.1.3</p>"},{"location":"api/get/#object_store_rs.GetOptions.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str | None\n</code></pre> <p>Request a particular object version</p>"},{"location":"api/get/#object_store_rs.GetResult","title":"object_store_rs.GetResult","text":"<p>Result for a get request</p>"},{"location":"api/get/#object_store_rs.GetResult.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: ObjectMeta\n</code></pre> <p>The ObjectMeta for this object</p>"},{"location":"api/get/#object_store_rs.GetResult.bytes","title":"bytes","text":"<pre><code>bytes() -&gt; bytes\n</code></pre> <p>Collects the data into bytes</p>"},{"location":"api/get/#object_store_rs.GetResult.bytes_async","title":"bytes_async  <code>async</code>","text":"<pre><code>bytes_async() -&gt; bytes\n</code></pre> <p>Collects the data into bytes</p>"},{"location":"api/head/","title":"Head","text":""},{"location":"api/head/#object_store_rs.head","title":"object_store_rs.head","text":"<pre><code>head(store: ObjectStore, location: str) -&gt; ObjectMeta\n</code></pre> <p>Return the metadata for the specified location</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>ObjectStore</code>)           \u2013            <p>The ObjectStore instance to use.</p> </li> <li> <code>location</code>               (<code>str</code>)           \u2013            <p>The path within ObjectStore to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ObjectMeta</code>           \u2013            <p>ObjectMeta</p> </li> </ul>"},{"location":"api/head/#object_store_rs.head_async","title":"object_store_rs.head_async  <code>async</code>","text":"<pre><code>head_async(store: ObjectStore, location: str) -&gt; ObjectMeta\n</code></pre> <p>Call <code>head</code> asynchronously.</p> <p>Refer to the documentation for head.</p>"},{"location":"api/list/","title":"List","text":""},{"location":"api/list/#object_store_rs.list","title":"object_store_rs.list","text":"<pre><code>list(store: ObjectStore, prefix: str | None = None) -&gt; List[ObjectMeta]\n</code></pre> <p>List all the objects with the given prefix.</p> <p>Prefixes are evaluated on a path segment basis, i.e. <code>foo/bar/</code> is a prefix of <code>foo/bar/x</code> but not of <code>foo/bar_baz/x</code>. List is recursive, i.e. <code>foo/bar/more/x</code> will be included.</p> <p>Note: the order of returned <code>ObjectMeta</code> is not guaranteed</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>ObjectStore</code>)           \u2013            <p>The ObjectStore instance to use.</p> </li> <li> <code>prefix</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The prefix within ObjectStore to use for listing. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[ObjectMeta]</code>           \u2013            <p>A list of <code>ObjectMeta</code>.</p> </li> </ul>"},{"location":"api/list/#object_store_rs.list_async","title":"object_store_rs.list_async  <code>async</code>","text":"<pre><code>list_async(store: ObjectStore, prefix: str | None = None) -&gt; List[ObjectMeta]\n</code></pre> <p>Call <code>list</code> asynchronously.</p> <p>Refer to the documentation for list.</p>"},{"location":"api/list/#object_store_rs.list_with_delimiter","title":"object_store_rs.list_with_delimiter","text":"<pre><code>list_with_delimiter(\n    store: ObjectStore, prefix: str | None = None\n) -&gt; ListResult\n</code></pre> <p>List objects with the given prefix and an implementation specific delimiter. Returns common prefixes (directories) in addition to object metadata.</p> <p>Prefixes are evaluated on a path segment basis, i.e. <code>foo/bar/</code> is a prefix of <code>foo/bar/x</code> but not of <code>foo/bar_baz/x</code>. List is not recursive, i.e. <code>foo/bar/more/x</code> will not be included.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>ObjectStore</code>)           \u2013            <p>The ObjectStore instance to use.</p> </li> <li> <code>prefix</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The prefix within ObjectStore to use for listing. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ListResult</code>           \u2013            <p>ListResult</p> </li> </ul>"},{"location":"api/list/#object_store_rs.list_with_delimiter_async","title":"object_store_rs.list_with_delimiter_async  <code>async</code>","text":"<pre><code>list_with_delimiter_async(\n    store: ObjectStore, prefix: str | None = None\n) -&gt; ListResult\n</code></pre> <p>Call <code>list_with_delimiter</code> asynchronously.</p> <p>Refer to the documentation for list_with_delimiter.</p>"},{"location":"api/list/#object_store_rs.ObjectMeta","title":"object_store_rs.ObjectMeta","text":"<p>               Bases: <code>TypedDict</code></p> <p>The metadata that describes an object.</p>"},{"location":"api/list/#object_store_rs.ObjectMeta.e_tag","title":"e_tag  <code>instance-attribute</code>","text":"<pre><code>e_tag: str | None\n</code></pre> <p>The unique identifier for the object</p> <p>datatracker.ietf.org/doc/html/rfc9110#name-etag</p>"},{"location":"api/list/#object_store_rs.ObjectMeta.last_modified","title":"last_modified  <code>instance-attribute</code>","text":"<pre><code>last_modified: datetime\n</code></pre> <p>The last modified time</p>"},{"location":"api/list/#object_store_rs.ObjectMeta.location","title":"location  <code>instance-attribute</code>","text":"<pre><code>location: str\n</code></pre> <p>The full path to the object</p>"},{"location":"api/list/#object_store_rs.ObjectMeta.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size: int\n</code></pre> <p>The size in bytes of the object</p>"},{"location":"api/list/#object_store_rs.ObjectMeta.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str | None\n</code></pre> <p>A version indicator for this object</p>"},{"location":"api/list/#object_store_rs.ListResult","title":"object_store_rs.ListResult","text":"<p>               Bases: <code>TypedDict</code></p> <p>Result of a list call that includes objects, prefixes (directories) and a token for the next set of results. Individual result sets may be limited to 1,000 objects based on the underlying object storage's limitations.</p>"},{"location":"api/list/#object_store_rs.ListResult.common_prefixes","title":"common_prefixes  <code>instance-attribute</code>","text":"<pre><code>common_prefixes: List[str]\n</code></pre> <p>Prefixes that are common (like directories)</p>"},{"location":"api/list/#object_store_rs.ListResult.objects","title":"objects  <code>instance-attribute</code>","text":"<pre><code>objects: List[ObjectMeta]\n</code></pre> <p>Object metadata for the listing</p>"},{"location":"api/put/","title":"Put","text":""},{"location":"api/put/#object_store_rs.put_file","title":"object_store_rs.put_file","text":"<pre><code>put_file(\n    store: ObjectStore,\n    location: str,\n    file: IO[bytes] | Path | bytes,\n    *,\n    chunk_size: int = 5 * 1024,\n    max_concurrency: int = 12\n) -&gt; None\n</code></pre> <p>Save the provided bytes to the specified location</p> <p>The operation is guaranteed to be atomic, it will either successfully write the entirety of <code>file</code> to <code>location</code>, or fail. No clients should be able to observe a partially written object.</p> <p>This will use a multipart upload under the hood.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>ObjectStore</code>)           \u2013            <p>The ObjectStore instance to use.</p> </li> <li> <code>location</code>               (<code>str</code>)           \u2013            <p>The path within ObjectStore for where to save the file.</p> </li> <li> <code>file</code>               (<code>IO[bytes] | Path | bytes</code>)           \u2013            <p>The object to upload. Can either be file-like, a <code>Path</code> to a local file, or a <code>bytes</code> object.</p> </li> <li> <code>chunk_size</code>               (<code>int</code>, default:                   <code>5 * 1024</code> )           \u2013            <p>The size of chunks to use within each part of the multipart upload. Defaults to 5 MB.</p> </li> <li> <code>max_concurrency</code>               (<code>int</code>, default:                   <code>12</code> )           \u2013            <p>The maximum number of chunks to upload concurrently. Defaults to 12.</p> </li> </ul>"},{"location":"api/put/#object_store_rs.put_file_async","title":"object_store_rs.put_file_async  <code>async</code>","text":"<pre><code>put_file_async(\n    store: ObjectStore,\n    location: str,\n    file: IO[bytes] | Path | bytes,\n    *,\n    chunk_size: int = 5 * 1024,\n    max_concurrency: int = 12\n) -&gt; None\n</code></pre> <p>Call <code>put_file</code> asynchronously.</p> <p>Refer to the documentation for put_file.</p>"},{"location":"api/rename/","title":"Rename","text":""},{"location":"api/rename/#object_store_rs.rename","title":"object_store_rs.rename","text":"<pre><code>rename(store: ObjectStore, from_: str, to: str) -&gt; None\n</code></pre> <p>Move an object from one path to another in the same object store.</p> <p>By default, this is implemented as a copy and then delete source. It may not check when deleting source that it was the same object that was originally copied.</p> <p>If there exists an object at the destination, it will be overwritten.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>ObjectStore</code>)           \u2013            <p>The ObjectStore instance to use.</p> </li> <li> <code>from_</code>               (<code>str</code>)           \u2013            <p>Source path</p> </li> <li> <code>to</code>               (<code>str</code>)           \u2013            <p>Destination path</p> </li> </ul>"},{"location":"api/rename/#object_store_rs.rename_async","title":"object_store_rs.rename_async  <code>async</code>","text":"<pre><code>rename_async(store: ObjectStore, from_: str, to: str) -&gt; None\n</code></pre> <p>Call <code>rename</code> asynchronously.</p> <p>Refer to the documentation for rename.</p>"},{"location":"api/sign/","title":"Sign","text":""},{"location":"api/sign/#object_store_rs.sign_url","title":"object_store_rs.sign_url","text":"<pre><code>sign_url(\n    store: SignCapableStore,\n    method: HTTP_METHOD,\n    path: str,\n    expires_in: timedelta,\n) -&gt; str\n</code></pre> <p>Create a signed URL.</p> <p>Given the intended [<code>Method</code>] and [<code>Path</code>] to use and the desired length of time for which the URL should be valid, return a signed [<code>Url</code>] created with the object store implementation's credentials such that the URL can be handed to something that doesn't have access to the object store's credentials, to allow limited access to the object store.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>SignCapableStore</code>)           \u2013            <p>The ObjectStore instance to use.</p> </li> <li> <code>method</code>               (<code>HTTP_METHOD</code>)           \u2013            <p>The HTTP method to use.</p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path within ObjectStore to retrieve.</p> </li> <li> <code>expires_in</code>               (<code>timedelta</code>)           \u2013            <p>How long the signed URL should be valid.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>description</p> </li> </ul>"},{"location":"api/sign/#object_store_rs.sign_url_async","title":"object_store_rs.sign_url_async  <code>async</code>","text":"<pre><code>sign_url_async(\n    store: SignCapableStore,\n    method: HTTP_METHOD,\n    path: str,\n    expires_in: timedelta,\n) -&gt; str\n</code></pre> <p>Call <code>sign_url</code> asynchronously.</p> <p>Refer to the documentation for sign_url.</p>"},{"location":"api/sign/#object_store_rs.SignCapableStore","title":"object_store_rs.SignCapableStore  <code>module-attribute</code>","text":"<pre><code>SignCapableStore = AzureStore | GCSStore | S3Store\n</code></pre> <p>ObjectStore instances that are capable of signing.</p>"},{"location":"api/sign/#object_store_rs.HTTP_METHOD","title":"object_store_rs.HTTP_METHOD  <code>module-attribute</code>","text":"<pre><code>HTTP_METHOD = Literal[\n    \"GET\",\n    \"PUT\",\n    \"POST\",\n    \"HEAD\",\n    \"PATCH\",\n    \"TRACE\",\n    \"DELETE\",\n    \"OPTIONS\",\n    \"CONNECT\",\n]\n</code></pre> <p>Allowed HTTP Methods for signing.</p>"},{"location":"api/store/","title":"ObjectStore","text":""},{"location":"api/store/#object_store_rs.store.ObjectStore","title":"object_store_rs.store.ObjectStore  <code>module-attribute</code>","text":"<pre><code>ObjectStore = (\n    AzureStore | GCSStore | HTTPStore | S3Store | LocalStore | MemoryStore\n)\n</code></pre> <p>All supported ObjectStore implementations.</p>"},{"location":"api/store/aws/","title":"AWS S3","text":""},{"location":"api/store/aws/#object_store_rs.store.S3Store","title":"object_store_rs.store.S3Store","text":"<p>Configure a connection to Amazon S3 using the specified credentials in the specified Amazon region and bucket.</p>"},{"location":"api/store/aws/#object_store_rs.store.S3Store.from_env","title":"from_env  <code>classmethod</code>","text":"<pre><code>from_env(\n    bucket: str,\n    *,\n    config: Dict[S3ConfigKey | str, str] | None = None,\n    client_options: Dict[ClientConfigKey, str] | None = None,\n    retry_config: RetryConfig | None = None\n) -&gt; S3Store\n</code></pre> <p>Construct a new S3Store with regular AWS environment variables</p> <p>Variables extracted from environment:</p> <ul> <li><code>AWS_ACCESS_KEY_ID</code> -&gt; access_key_id</li> <li><code>AWS_SECRET_ACCESS_KEY</code> -&gt; secret_access_key</li> <li><code>AWS_DEFAULT_REGION</code> -&gt; region</li> <li><code>AWS_ENDPOINT</code> -&gt; endpoint</li> <li><code>AWS_SESSION_TOKEN</code> -&gt; token</li> <li><code>AWS_CONTAINER_CREDENTIALS_RELATIVE_URI</code> -&gt; docs.aws.amazon.com/AmazonECS/latest/developerguide/task-iam-roles.html</li> <li><code>AWS_ALLOW_HTTP</code> -&gt; set to \"true\" to permit HTTP connections without TLS</li> </ul> <p>Parameters:</p> <ul> <li> <code>bucket</code>               (<code>str</code>)           \u2013            <p>The AWS bucket to use.</p> </li> <li> <code>config</code>               (<code>Dict[S3ConfigKey | str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>AWS Configuration. Values in this config will override values inferred from the environment. Defaults to None.</p> </li> <li> <code>client_options</code>               (<code>Dict[ClientConfigKey, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>HTTP Client options. Defaults to None.</p> </li> <li> <code>retry_config</code>               (<code>RetryConfig | None</code>, default:                   <code>None</code> )           \u2013            <p>Retry configuration. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>S3Store</code>           \u2013            <p>S3Store</p> </li> </ul>"},{"location":"api/store/aws/#object_store_rs.store.S3Store.from_session","title":"from_session  <code>classmethod</code>","text":"<pre><code>from_session(\n    session: Session | Session,\n    bucket: str,\n    *,\n    config: Dict[S3ConfigKey | str, str] | None = None,\n    client_options: Dict[ClientConfigKey, str] | None = None,\n    retry_config: RetryConfig | None = None\n) -&gt; S3Store\n</code></pre> <p>Construct a new S3Store with credentials inferred from a boto3 Session</p> <p>Parameters:</p> <ul> <li> <code>session</code>               (<code>Session | Session</code>)           \u2013            <p>The boto3.Session or botocore.session.Session to infer credentials from.</p> </li> <li> <code>bucket</code>               (<code>str</code>)           \u2013            <p>The AWS bucket to use.</p> </li> <li> <code>config</code>               (<code>Dict[S3ConfigKey | str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>AWS Configuration. Values in this config will override values inferred from the session. Defaults to None.</p> </li> <li> <code>client_options</code>               (<code>Dict[ClientConfigKey, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>HTTP Client options. Defaults to None.</p> </li> <li> <code>retry_config</code>               (<code>RetryConfig | None</code>, default:                   <code>None</code> )           \u2013            <p>Retry configuration. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>S3Store</code>           \u2013            <p>S3Store</p> </li> </ul>"},{"location":"api/store/aws/#object_store_rs.store.S3Store.from_url","title":"from_url  <code>classmethod</code>","text":"<pre><code>from_url(\n    url: str,\n    *,\n    config: Dict[S3ConfigKey | str, str] | None = None,\n    client_options: Dict[ClientConfigKey, str] | None = None,\n    retry_config: RetryConfig | None = None\n) -&gt; S3Store\n</code></pre> <p>Parse available connection info from a well-known storage URL.</p> <p>The supported url schemes are:</p> <ul> <li><code>s3://&lt;bucket&gt;/&lt;path&gt;</code></li> <li><code>s3a://&lt;bucket&gt;/&lt;path&gt;</code></li> <li><code>https://s3.&lt;region&gt;.amazonaws.com/&lt;bucket&gt;</code></li> <li><code>https://&lt;bucket&gt;.s3.&lt;region&gt;.amazonaws.com</code></li> <li><code>https://ACCOUNT_ID.r2.cloudflarestorage.com/bucket</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>well-known storage URL.</p> </li> <li> <code>config</code>               (<code>Dict[S3ConfigKey | str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>AWS Configuration. Values in this config will override values inferred from the url. Defaults to None.</p> </li> <li> <code>client_options</code>               (<code>Dict[ClientConfigKey, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>HTTP Client options. Defaults to None.</p> </li> <li> <code>retry_config</code>               (<code>RetryConfig | None</code>, default:                   <code>None</code> )           \u2013            <p>Retry configuration. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>S3Store</code>           \u2013            <p>S3Store</p> </li> </ul>"},{"location":"api/store/aws/#object_store_rs.store.S3ConfigKey","title":"object_store_rs.store.S3ConfigKey  <code>module-attribute</code>","text":"<pre><code>S3ConfigKey = Literal[\n    \"access_key_id\",\n    \"aws_access_key_id\",\n    \"aws_allow_http\",\n    \"aws_bucket_name\",\n    \"aws_bucket\",\n    \"aws_checksum_algorithm\",\n    \"aws_conditional_put\",\n    \"aws_container_credentials_relative_uri\",\n    \"aws_copy_if_not_exists\",\n    \"aws_default_region\",\n    \"aws_disable_tagging\",\n    \"aws_endpoint_url\",\n    \"aws_endpoint\",\n    \"aws_imdsv1_fallback\",\n    \"aws_metadata_endpoint\",\n    \"aws_region\",\n    \"aws_s3_express\",\n    \"aws_secret_access_key\",\n    \"aws_server_side_encryption\",\n    \"aws_session_token\",\n    \"aws_skip_signature\",\n    \"aws_sse_bucket_key_enabled\",\n    \"aws_sse_kms_key_id\",\n    \"aws_token\",\n    \"aws_unsigned_payload\",\n    \"aws_virtual_hosted_style_request\",\n    \"bucket_name\",\n    \"bucket\",\n    \"checksum_algorithm\",\n    \"conditional_put\",\n    \"copy_if_not_exists\",\n    \"default_region\",\n    \"disable_tagging\",\n    \"endpoint_url\",\n    \"endpoint\",\n    \"imdsv1_fallback\",\n    \"metadata_endpoint\",\n    \"region\",\n    \"s3_express\",\n    \"secret_access_key\",\n    \"session_token\",\n    \"skip_signature\",\n    \"token\",\n    \"unsigned_payload\",\n    \"virtual_hosted_style_request\",\n    \"ACCESS_KEY_ID\",\n    \"AWS_ACCESS_KEY_ID\",\n    \"AWS_ALLOW_HTTP\",\n    \"AWS_BUCKET_NAME\",\n    \"AWS_BUCKET\",\n    \"AWS_CHECKSUM_ALGORITHM\",\n    \"AWS_CONDITIONAL_PUT\",\n    \"AWS_CONTAINER_CREDENTIALS_RELATIVE_URI\",\n    \"AWS_COPY_IF_NOT_EXISTS\",\n    \"AWS_DEFAULT_REGION\",\n    \"AWS_DISABLE_TAGGING\",\n    \"AWS_ENDPOINT_URL\",\n    \"AWS_ENDPOINT\",\n    \"AWS_IMDSV1_FALLBACK\",\n    \"AWS_METADATA_ENDPOINT\",\n    \"AWS_REGION\",\n    \"AWS_S3_EXPRESS\",\n    \"AWS_SECRET_ACCESS_KEY\",\n    \"AWS_SERVER_SIDE_ENCRYPTION\",\n    \"AWS_SESSION_TOKEN\",\n    \"AWS_SKIP_SIGNATURE\",\n    \"AWS_SSE_BUCKET_KEY_ENABLED\",\n    \"AWS_SSE_KMS_KEY_ID\",\n    \"AWS_TOKEN\",\n    \"AWS_UNSIGNED_PAYLOAD\",\n    \"AWS_VIRTUAL_HOSTED_STYLE_REQUEST\",\n    \"BUCKET_NAME\",\n    \"BUCKET\",\n    \"CHECKSUM_ALGORITHM\",\n    \"CONDITIONAL_PUT\",\n    \"COPY_IF_NOT_EXISTS\",\n    \"DEFAULT_REGION\",\n    \"DISABLE_TAGGING\",\n    \"ENDPOINT_URL\",\n    \"ENDPOINT\",\n    \"IMDSV1_FALLBACK\",\n    \"METADATA_ENDPOINT\",\n    \"REGION\",\n    \"S3_EXPRESS\",\n    \"SECRET_ACCESS_KEY\",\n    \"SESSION_TOKEN\",\n    \"SKIP_SIGNATURE\",\n    \"TOKEN\",\n    \"UNSIGNED_PAYLOAD\",\n    \"VIRTUAL_HOSTED_STYLE_REQUEST\",\n]\n</code></pre> <p>Valid AWS S3 configuration keys.</p>"},{"location":"api/store/azure/","title":"Microsoft Azure","text":""},{"location":"api/store/azure/#object_store_rs.store.AzureStore","title":"object_store_rs.store.AzureStore","text":"<p>Configure a connection to Microsoft Azure Blob Storage container using the specified credentials.</p>"},{"location":"api/store/azure/#object_store_rs.store.AzureStore.from_env","title":"from_env  <code>classmethod</code>","text":"<pre><code>from_env(\n    container: str,\n    *,\n    config: Dict[AzureConfigKey, str] | None = None,\n    client_options: Dict[ClientConfigKey, str] | None = None,\n    retry_config: RetryConfig | None = None\n) -&gt; AzureStore\n</code></pre> <p>Construct a new AzureStore with values pre-populated from environment variables.</p> <p>Variables extracted from environment:</p> <ul> <li><code>AZURE_STORAGE_ACCOUNT_NAME</code>: storage account name</li> <li><code>AZURE_STORAGE_ACCOUNT_KEY</code>: storage account master key</li> <li><code>AZURE_STORAGE_ACCESS_KEY</code>: alias for <code>AZURE_STORAGE_ACCOUNT_KEY</code></li> <li><code>AZURE_STORAGE_CLIENT_ID</code> -&gt; client id for service principal authorization</li> <li><code>AZURE_STORAGE_CLIENT_SECRET</code> -&gt; client secret for service principal authorization</li> <li><code>AZURE_STORAGE_TENANT_ID</code> -&gt; tenant id used in oauth flows</li> </ul> <p>Parameters:</p> <ul> <li> <code>container</code>               (<code>str</code>)           \u2013            <p>description</p> </li> <li> <code>config</code>               (<code>Dict[AzureConfigKey, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Azure Configuration. Values in this config will override values inferred from the url. Defaults to None.</p> </li> <li> <code>client_options</code>               (<code>Dict[ClientConfigKey, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>HTTP Client options. Defaults to None.</p> </li> <li> <code>retry_config</code>               (<code>RetryConfig | None</code>, default:                   <code>None</code> )           \u2013            <p>Retry configuration. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AzureStore</code>           \u2013            <p>AzureStore</p> </li> </ul>"},{"location":"api/store/azure/#object_store_rs.store.AzureStore.from_url","title":"from_url  <code>classmethod</code>","text":"<pre><code>from_url(\n    url: str,\n    *,\n    config: Dict[AzureConfigKey, str] | None = None,\n    client_options: Dict[ClientConfigKey, str] | None = None,\n    retry_config: RetryConfig | None = None\n) -&gt; AzureStore\n</code></pre> <p>Construct a new AzureStore with values populated from a well-known storage URL.</p> <p>The supported url schemes are:</p> <ul> <li><code>abfs[s]://&lt;container&gt;/&lt;path&gt;</code> (according to fsspec)</li> <li><code>abfs[s]://&lt;file_system&gt;@&lt;account_name&gt;.dfs.core.windows.net/&lt;path&gt;</code></li> <li><code>abfs[s]://&lt;file_system&gt;@&lt;account_name&gt;.dfs.fabric.microsoft.com/&lt;path&gt;</code></li> <li><code>az://&lt;container&gt;/&lt;path&gt;</code> (according to fsspec)</li> <li><code>adl://&lt;container&gt;/&lt;path&gt;</code> (according to fsspec)</li> <li><code>azure://&lt;container&gt;/&lt;path&gt;</code> (custom)</li> <li><code>https://&lt;account&gt;.dfs.core.windows.net</code></li> <li><code>https://&lt;account&gt;.blob.core.windows.net</code></li> <li><code>https://&lt;account&gt;.blob.core.windows.net/&lt;container&gt;</code></li> <li><code>https://&lt;account&gt;.dfs.fabric.microsoft.com</code></li> <li><code>https://&lt;account&gt;.dfs.fabric.microsoft.com/&lt;container&gt;</code></li> <li><code>https://&lt;account&gt;.blob.fabric.microsoft.com</code></li> <li><code>https://&lt;account&gt;.blob.fabric.microsoft.com/&lt;container&gt;</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>well-known storage URL.</p> </li> <li> <code>config</code>               (<code>Dict[AzureConfigKey, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Azure Configuration. Values in this config will override values inferred from the url. Defaults to None.</p> </li> <li> <code>client_options</code>               (<code>Dict[ClientConfigKey, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>HTTP Client options. Defaults to None.</p> </li> <li> <code>retry_config</code>               (<code>RetryConfig | None</code>, default:                   <code>None</code> )           \u2013            <p>Retry configuration. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AzureStore</code>           \u2013            <p>AzureStore</p> </li> </ul>"},{"location":"api/store/azure/#object_store_rs.store.AzureConfigKey","title":"object_store_rs.store.AzureConfigKey  <code>module-attribute</code>","text":"<pre><code>AzureConfigKey = Literal[\n    \"access_key\",\n    \"account_key\",\n    \"account_name\",\n    \"authority_id\",\n    \"azure_authority_id\",\n    \"azure_client_id\",\n    \"azure_client_secret\",\n    \"azure_container_name\",\n    \"azure_disable_tagging\",\n    \"azure_endpoint\",\n    \"azure_federated_token_file\",\n    \"azure_identity_endpoint\",\n    \"azure_msi_endpoint\",\n    \"azure_msi_resource_id\",\n    \"azure_object_id\",\n    \"azure_skip_signature\",\n    \"azure_storage_access_key\",\n    \"azure_storage_account_key\",\n    \"azure_storage_account_name\",\n    \"azure_storage_authority_id\",\n    \"azure_storage_client_id\",\n    \"azure_storage_client_secret\",\n    \"azure_storage_endpoint\",\n    \"azure_storage_master_key\",\n    \"azure_storage_sas_key\",\n    \"azure_storage_sas_token\",\n    \"azure_storage_tenant_id\",\n    \"azure_storage_token\",\n    \"azure_storage_use_emulator\",\n    \"azure_tenant_id\",\n    \"azure_use_azure_cli\",\n    \"azure_use_fabric_endpoint\",\n    \"bearer_token\",\n    \"client_id\",\n    \"client_secret\",\n    \"container_name\",\n    \"disable_tagging\",\n    \"endpoint\",\n    \"federated_token_file\",\n    \"identity_endpoint\",\n    \"master_key\",\n    \"msi_endpoint\",\n    \"msi_resource_id\",\n    \"object_id\",\n    \"sas_key\",\n    \"sas_token\",\n    \"skip_signature\",\n    \"tenant_id\",\n    \"token\",\n    \"use_azure_cli\",\n    \"use_emulator\",\n    \"use_fabric_endpoint\",\n    \"ACCESS_KEY\",\n    \"ACCOUNT_KEY\",\n    \"ACCOUNT_NAME\",\n    \"AUTHORITY_ID\",\n    \"AZURE_AUTHORITY_ID\",\n    \"AZURE_CLIENT_ID\",\n    \"AZURE_CLIENT_SECRET\",\n    \"AZURE_CONTAINER_NAME\",\n    \"AZURE_DISABLE_TAGGING\",\n    \"AZURE_ENDPOINT\",\n    \"AZURE_FEDERATED_TOKEN_FILE\",\n    \"AZURE_IDENTITY_ENDPOINT\",\n    \"AZURE_MSI_ENDPOINT\",\n    \"AZURE_MSI_RESOURCE_ID\",\n    \"AZURE_OBJECT_ID\",\n    \"AZURE_SKIP_SIGNATURE\",\n    \"AZURE_STORAGE_ACCESS_KEY\",\n    \"AZURE_STORAGE_ACCOUNT_KEY\",\n    \"AZURE_STORAGE_ACCOUNT_NAME\",\n    \"AZURE_STORAGE_AUTHORITY_ID\",\n    \"AZURE_STORAGE_CLIENT_ID\",\n    \"AZURE_STORAGE_CLIENT_SECRET\",\n    \"AZURE_STORAGE_ENDPOINT\",\n    \"AZURE_STORAGE_MASTER_KEY\",\n    \"AZURE_STORAGE_SAS_KEY\",\n    \"AZURE_STORAGE_SAS_TOKEN\",\n    \"AZURE_STORAGE_TENANT_ID\",\n    \"AZURE_STORAGE_TOKEN\",\n    \"AZURE_STORAGE_USE_EMULATOR\",\n    \"AZURE_TENANT_ID\",\n    \"AZURE_USE_AZURE_CLI\",\n    \"AZURE_USE_FABRIC_ENDPOINT\",\n    \"BEARER_TOKEN\",\n    \"CLIENT_ID\",\n    \"CLIENT_SECRET\",\n    \"CONTAINER_NAME\",\n    \"DISABLE_TAGGING\",\n    \"ENDPOINT\",\n    \"FEDERATED_TOKEN_FILE\",\n    \"IDENTITY_ENDPOINT\",\n    \"MASTER_KEY\",\n    \"MSI_ENDPOINT\",\n    \"MSI_RESOURCE_ID\",\n    \"OBJECT_ID\",\n    \"SAS_KEY\",\n    \"SAS_TOKEN\",\n    \"SKIP_SIGNATURE\",\n    \"TENANT_ID\",\n    \"TOKEN\",\n    \"USE_AZURE_CLI\",\n    \"USE_EMULATOR\",\n    \"USE_FABRIC_ENDPOINT\",\n]\n</code></pre> <p>Valid Azure storage configuration keys</p> <p>Either lower case or upper case strings are accepted.</p> <ul> <li><code>\"azure_storage_account_key\"</code>, <code>\"azure_storage_access_key\"</code>, <code>\"azure_storage_master_key\"</code>, <code>\"master_key\"</code>, <code>\"account_key\"</code>, <code>\"access_key\"</code>: Master key for accessing storage account</li> <li><code>\"azure_storage_account_name\"</code>, <code>\"account_name\"</code>: The name of the azure storage account</li> <li><code>\"azure_storage_client_id\"</code>, <code>\"azure_client_id\"</code>, <code>\"client_id\"</code>: Service principal client id for authorizing requests</li> <li><code>\"azure_storage_client_secret\"</code>, <code>\"azure_client_secret\"</code>, <code>\"client_secret\"</code>: Service principal client secret for authorizing requests</li> <li><code>\"azure_storage_tenant_id\"</code>, <code>\"azure_storage_authority_id\"</code>, <code>\"azure_tenant_id\"</code>, <code>\"azure_authority_id\"</code>, <code>\"tenant_id\"</code>, <code>\"authority_id\"</code>: Tenant id used in oauth flows</li> <li> <p><code>\"azure_storage_sas_key\"</code>, <code>\"azure_storage_sas_token\"</code>, <code>\"sas_key\"</code>, <code>\"sas_token\"</code>: Shared access signature.</p> <p>The signature is expected to be percent-encoded, <code>much</code>like they are provided in the azure storage explorer or azure portal.</p> </li> <li> <p><code>\"azure_storage_token\"</code>, <code>\"bearer_token\"</code>, <code>\"token\"</code>: Bearer token</p> </li> <li><code>\"azure_storage_use_emulator\"</code>, <code>\"use_emulator\"</code>: Use object store with azurite storage emulator</li> <li><code>\"azure_storage_endpoint\"</code>, <code>\"azure_endpoint\"</code>, <code>\"endpoint\"</code>: Override the endpoint used to communicate with blob storage</li> <li><code>\"azure_msi_endpoint\"</code>, <code>\"azure_identity_endpoint\"</code>, <code>\"identity_endpoint\"</code>, <code>\"msi_endpoint\"</code>: Endpoint to request a imds managed identity token</li> <li><code>\"azure_object_id\"</code>, <code>\"object_id\"</code>: Object id for use with managed identity authentication</li> <li><code>\"azure_msi_resource_id\"</code>, <code>\"msi_resource_id\"</code>: Msi resource id for use with managed identity authentication</li> <li><code>\"azure_federated_token_file\"</code>, <code>\"federated_token_file\"</code>: File containing token for Azure AD workload identity federation</li> <li><code>\"azure_use_fabric_endpoint\"</code>, <code>\"use_fabric_endpoint\"</code>: Use object store with url scheme account.dfs.fabric.microsoft.com</li> <li><code>\"azure_use_azure_cli\"</code>, <code>\"use_azure_cli\"</code>: Use azure cli for acquiring access token</li> <li><code>\"azure_skip_signature\"</code>, <code>\"skip_signature\"</code>: Skip signing requests</li> <li><code>\"azure_container_name\"</code>, <code>\"container_name\"</code>: Container name</li> <li><code>\"azure_disable_tagging\"</code>, <code>\"disable_tagging\"</code>: Disables tagging objects</li> </ul>"},{"location":"api/store/config/","title":"Configuration","text":""},{"location":"api/store/config/#object_store_rs.store.ClientConfigKey","title":"object_store_rs.store.ClientConfigKey  <code>module-attribute</code>","text":"<pre><code>ClientConfigKey = Literal[\n    \"allow_http\",\n    \"allow_invalid_certificates\",\n    \"connect_timeout\",\n    \"default_content_type\",\n    \"http1_only\",\n    \"http2_keep_alive_interval\",\n    \"http2_keep_alive_timeout\",\n    \"http2_keep_alive_while_idle\",\n    \"http2_only\",\n    \"pool_idle_timeout\",\n    \"pool_max_idle_per_host\",\n    \"proxy_url\",\n    \"timeout\",\n    \"user_agent\",\n    \"ALLOW_HTTP\",\n    \"ALLOW_INVALID_CERTIFICATES\",\n    \"CONNECT_TIMEOUT\",\n    \"DEFAULT_CONTENT_TYPE\",\n    \"HTTP1_ONLY\",\n    \"HTTP2_KEEP_ALIVE_INTERVAL\",\n    \"HTTP2_KEEP_ALIVE_TIMEOUT\",\n    \"HTTP2_KEEP_ALIVE_WHILE_IDLE\",\n    \"HTTP2_ONLY\",\n    \"POOL_IDLE_TIMEOUT\",\n    \"POOL_MAX_IDLE_PER_HOST\",\n    \"PROXY_URL\",\n    \"TIMEOUT\",\n    \"USER_AGENT\",\n]\n</code></pre> <p>Allowed client configuration keys</p> <p>Either lower case or upper case strings are accepted.</p> <ul> <li><code>\"allow_http\"</code>: Allow non-TLS, i.e. non-HTTPS connections.</li> <li> <p><code>\"allow_invalid_certificates\"</code>: Skip certificate validation on https connections.</p> <p>Warning</p> <p>You should think very carefully before using this method. If invalid certificates are trusted, any certificate for any site will be trusted for use. This includes expired certificates. This introduces significant vulnerabilities, and should only be used as a last resort or for testing</p> </li> <li> <p><code>\"connect_timeout\"</code>: Timeout for only the connect phase of a Client</p> </li> <li><code>\"default_content_type\"</code>: default <code>CONTENT_TYPE</code> for uploads</li> <li><code>\"http1_only\"</code>: Only use http1 connections.</li> <li><code>\"http2_keep_alive_interval\"</code>: Interval for HTTP2 Ping frames should be sent to keep a connection alive.</li> <li><code>\"http2_keep_alive_timeout\"</code>: Timeout for receiving an acknowledgement of the keep-alive ping.</li> <li><code>\"http2_keep_alive_while_idle\"</code>: Enable HTTP2 keep alive pings for idle connections</li> <li><code>\"http2_only\"</code>: Only use http2 connections</li> <li><code>\"pool_idle_timeout\"</code>: The pool max idle timeout.     This is the length of time an idle connection will be kept alive.</li> <li><code>\"pool_max_idle_per_host\"</code>: maximum number of idle connections per host.</li> <li><code>\"proxy_url\"</code>: HTTP proxy to use for requests.</li> <li><code>\"timeout\"</code>: Request timeout.     The timeout is applied from when the request starts connecting until the     response body has finished.</li> <li><code>\"user_agent\"</code>: User-Agent header to be used by this client.</li> </ul>"},{"location":"api/store/config/#object_store_rs.store.BackoffConfig","title":"object_store_rs.store.BackoffConfig","text":"<p>               Bases: <code>TypedDict</code></p> <p>Exponential backoff with jitter</p> <p>See aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/</p>"},{"location":"api/store/config/#object_store_rs.store.BackoffConfig.base","title":"base  <code>instance-attribute</code>","text":"<pre><code>base: int | float\n</code></pre> <p>The base of the exponential to use</p>"},{"location":"api/store/config/#object_store_rs.store.BackoffConfig.init_backoff","title":"init_backoff  <code>instance-attribute</code>","text":"<pre><code>init_backoff: timedelta\n</code></pre> <p>The initial backoff duration</p>"},{"location":"api/store/config/#object_store_rs.store.BackoffConfig.max_backoff","title":"max_backoff  <code>instance-attribute</code>","text":"<pre><code>max_backoff: timedelta\n</code></pre> <p>The maximum backoff duration</p>"},{"location":"api/store/config/#object_store_rs.store.RetryConfig","title":"object_store_rs.store.RetryConfig","text":"<p>               Bases: <code>TypedDict</code></p> <p>The configuration for how to respond to request errors</p> <p>The following categories of error will be retried:</p> <ul> <li>5xx server errors</li> <li>Connection errors</li> <li>Dropped connections</li> <li>Timeouts for safe / read-only requests</li> </ul> <p>Requests will be retried up to some limit, using exponential backoff with jitter. See <code>BackoffConfig</code> for more information</p>"},{"location":"api/store/config/#object_store_rs.store.RetryConfig.backoff","title":"backoff  <code>instance-attribute</code>","text":"<pre><code>backoff: BackoffConfig\n</code></pre> <p>The backoff configuration</p>"},{"location":"api/store/config/#object_store_rs.store.RetryConfig.max_retries","title":"max_retries  <code>instance-attribute</code>","text":"<pre><code>max_retries: int\n</code></pre> <p>The maximum number of times to retry a request</p> <p>Set to 0 to disable retries</p>"},{"location":"api/store/config/#object_store_rs.store.RetryConfig.retry_timeout","title":"retry_timeout  <code>instance-attribute</code>","text":"<pre><code>retry_timeout: timedelta\n</code></pre> <p>The maximum length of time from the initial request after which no further retries will be attempted</p> <p>This not only bounds the length of time before a server error will be surfaced to the application, but also bounds the length of time a request's credentials must remain valid.</p> <p>As requests are retried without renewing credentials or regenerating request payloads, this number should be kept below 5 minutes to avoid errors due to expired credentials and/or request payloads</p>"},{"location":"api/store/gcs/","title":"Google Cloud Storage","text":""},{"location":"api/store/gcs/#object_store_rs.store.GCSStore","title":"object_store_rs.store.GCSStore","text":"<p>Configure a connection to Google Cloud Storage.</p> <p>If no credentials are explicitly provided, they will be sourced from the environment as documented here.</p>"},{"location":"api/store/gcs/#object_store_rs.store.GCSStore.from_env","title":"from_env  <code>classmethod</code>","text":"<pre><code>from_env(\n    bucket: str,\n    *,\n    config: Dict[GCSConfigKey, str] | None = None,\n    client_options: Dict[ClientConfigKey, str] | None = None,\n    retry_config: RetryConfig | None = None\n) -&gt; GCSStore\n</code></pre> <p>Construct a new GCSStore with values pre-populated from environment variables.</p> <p>Variables extracted from environment:</p> <ul> <li><code>GOOGLE_SERVICE_ACCOUNT</code>: location of service account file</li> <li><code>GOOGLE_SERVICE_ACCOUNT_PATH</code>: (alias) location of service account file</li> <li><code>SERVICE_ACCOUNT</code>: (alias) location of service account file</li> <li><code>GOOGLE_SERVICE_ACCOUNT_KEY</code>: JSON serialized service account key</li> <li><code>GOOGLE_BUCKET</code>: bucket name</li> <li><code>GOOGLE_BUCKET_NAME</code>: (alias) bucket name</li> </ul> <p>Parameters:</p> <ul> <li> <code>bucket</code>               (<code>str</code>)           \u2013            <p>The GCS bucket to use.</p> </li> <li> <code>config</code>               (<code>Dict[GCSConfigKey, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>GCS Configuration. Values in this config will override values inferred from the environment. Defaults to None.</p> </li> <li> <code>client_options</code>               (<code>Dict[ClientConfigKey, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>HTTP Client options. Defaults to None.</p> </li> <li> <code>retry_config</code>               (<code>RetryConfig | None</code>, default:                   <code>None</code> )           \u2013            <p>Retry configuration. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GCSStore</code>           \u2013            <p>GCSStore</p> </li> </ul>"},{"location":"api/store/gcs/#object_store_rs.store.GCSStore.from_url","title":"from_url  <code>classmethod</code>","text":"<pre><code>from_url(\n    url: str,\n    *,\n    config: Dict[GCSConfigKey, str] | None = None,\n    client_options: Dict[ClientConfigKey, str] | None = None,\n    retry_config: RetryConfig | None = None\n) -&gt; GCSStore\n</code></pre> <p>Construct a new GCSStore with values populated from a well-known storage URL.</p> <p>The supported url schemes are:</p> <ul> <li><code>gs://&lt;bucket&gt;/&lt;path&gt;</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>well-known storage URL.</p> </li> <li> <code>config</code>               (<code>Dict[GCSConfigKey, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>GCS Configuration. Values in this config will override values inferred from the url. Defaults to None.</p> </li> <li> <code>client_options</code>               (<code>Dict[ClientConfigKey, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>HTTP Client options. Defaults to None.</p> </li> <li> <code>retry_config</code>               (<code>RetryConfig | None</code>, default:                   <code>None</code> )           \u2013            <p>Retry configuration. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GCSStore</code>           \u2013            <p>GCSStore</p> </li> </ul>"},{"location":"api/store/gcs/#object_store_rs.store.GCSConfigKey","title":"object_store_rs.store.GCSConfigKey  <code>module-attribute</code>","text":"<pre><code>GCSConfigKey = Literal[\n    \"bucket_name\",\n    \"bucket\",\n    \"google_application_credentials\",\n    \"google_bucket_name\",\n    \"google_bucket\",\n    \"google_service_account_key\",\n    \"google_service_account_path\",\n    \"google_service_account\",\n    \"service_account_key\",\n    \"service_account_path\",\n    \"service_account\",\n    \"BUCKET_NAME\",\n    \"BUCKET\",\n    \"GOOGLE_APPLICATION_CREDENTIALS\",\n    \"GOOGLE_BUCKET_NAME\",\n    \"GOOGLE_BUCKET\",\n    \"GOOGLE_SERVICE_ACCOUNT_KEY\",\n    \"GOOGLE_SERVICE_ACCOUNT_PATH\",\n    \"GOOGLE_SERVICE_ACCOUNT\",\n    \"SERVICE_ACCOUNT_KEY\",\n    \"SERVICE_ACCOUNT_PATH\",\n    \"SERVICE_ACCOUNT\",\n]\n</code></pre> <p>Valid Google Cloud Storage configuration keys</p> <p>Either lower case or upper case strings are accepted.</p> <ul> <li><code>\"google_service_account\"</code> or <code>\"service_account\"</code> or <code>\"google_service_account_path\"</code> or \"service_account_path\":  Path to the service account file.</li> <li><code>\"google_service_account_key\"</code> or <code>\"service_account_key\"</code>: The serialized service account key</li> <li><code>\"google_bucket\"</code> or <code>\"google_bucket_name\"</code> or <code>\"bucket\"</code> or <code>\"bucket_name\"</code>: Bucket name.</li> <li><code>\"google_application_credentials\"</code>: Application credentials path. See cloud.google.com/docs/authentication/provide-credentials-adc.</li> </ul>"},{"location":"api/store/http/","title":"HTTP","text":""},{"location":"api/store/http/#object_store_rs.store.HTTPStore","title":"object_store_rs.store.HTTPStore","text":"<p>Configure a connection to a generic HTTP server</p>"},{"location":"api/store/http/#object_store_rs.store.HTTPStore.from_url","title":"from_url  <code>classmethod</code>","text":"<pre><code>from_url(\n    url: str,\n    *,\n    client_options: Dict[ClientConfigKey, str] | None = None,\n    retry_config: RetryConfig | None = None\n) -&gt; HTTPStore\n</code></pre> <p>Construct a new HTTPStore from a URL</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>The base URL to use for the store.</p> </li> <li> <code>client_options</code>               (<code>Dict[ClientConfigKey, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>HTTP Client options. Defaults to None.</p> </li> <li> <code>retry_config</code>               (<code>RetryConfig | None</code>, default:                   <code>None</code> )           \u2013            <p>Retry configuration. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>HTTPStore</code>           \u2013            <p>HTTPStore</p> </li> </ul>"},{"location":"api/store/local/","title":"Local","text":""},{"location":"api/store/local/#object_store_rs.store.LocalStore","title":"object_store_rs.store.LocalStore","text":"<p>Local filesystem storage providing an ObjectStore interface to files on local disk. Can optionally be created with a directory prefix.</p> <pre><code>store = LocalStore()\nstore = LocalStore(prefix=\"/path/to/directory\")\n</code></pre>"},{"location":"api/store/memory/","title":"Memory","text":""},{"location":"api/store/memory/#object_store_rs.store.MemoryStore","title":"object_store_rs.store.MemoryStore","text":"<p>A fully in-memory implementation of ObjectStore.</p> <p>Create a new in-memory store: <pre><code>store = MemoryStore()\n</code></pre></p>"}]}